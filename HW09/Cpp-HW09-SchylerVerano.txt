2. You would mark a method as virtual when you want to allow derived classes to override that method and ensure that the correct version is called based on the actual object type at runtime. This enables polymorphism, which is essential when working with class hierarchies where a base-class pointer or reference may refer to different derived objects, and you need behavior that adapts accordingly. However, you might choose not to mark a method as virtual when you do not intend for derived classes to override it, or when runtime polymorphism is unnecessary. Avoiding virtual functions can also reduce overhead, since virtual methods involve a vtable lookup, which can slightly impact performance and increase memory usage. In cases where performance is critical or when a method must not be overridden for logical or safety reasons, keeping it non-virtual is the better choice.

4. The difference between dynamic_cast and static_cast in C++ lies in how they handle type conversions, especially in class hierarchies. static_cast performs compile-time type checking and is used for conversions that the compiler can verify as safe, such as converting between related pointer or reference types in a hierarchy when you are certain of the object’s actual type. It does not check at runtime whether the object truly matches the target type, so using it incorrectly can lead to undefined behavior. In contrast, dynamic_cast performs runtime type checking and is used when you need to safely downcast a pointer or reference to a derived class in a polymorphic hierarchy. If the object cannot be converted, dynamic_cast returns nullptr for pointers or throws an exception for references, preventing unsafe access. You would use dynamic_cast when there is uncertainty about the actual type of the object at runtime and safety is a concern, while static_cast is preferred for conversions that are guaranteed to be valid and when performance is more critical.

6. You might use const_cast in C++ when you need to add or remove the const qualifier from a variable, usually in situations where a function’s interface requires a non-const argument but you have a const object that you know is safe to modify. For example, you might pass a const pointer to a legacy API that doesn’t accept const parameters, or you might temporarily remove const to modify a member of an object that was originally declared const but whose modification is logically safe. However, using const_cast can be dangerous if you try to modify an object that is actually defined as const, because this results in undefined behavior. Therefore, const_cast is typically reserved for situations where you have full control over the object and need to work around const-correctness for compatibility, rather than as a routine way to change constness.

7. if (dynamic_cast<Quadrilateral*>(s) != nullptr)

9. The code throws a pointer to an exception rather than the exception object itself. Exceptions should be  thrown by value and not by pointer. Throwing a pointer can lead to memory leaks if it’s not properly deleted. So, I would throw the object itself. 
